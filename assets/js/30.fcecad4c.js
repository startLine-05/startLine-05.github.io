(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{543:function(t,s,a){"use strict";a.r(s);var e=a(3),v=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",[t._v("由于 JavaScript 单线程语言，虽然在 html5 中提出了 Web-Worker ，但这并未改变 JavaScript 是单线程这一核心,可是浏览器又能很好的处理异步请求，那么到底是为什么呢？")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",[t._v("在解释事件循环之前首先先解释一下浏览器的执行线程：")]),t._v(" "),a("ul",[a("li",[t._v("浏览器是多进程的，浏览器每一个 tab 标签都代表一个独立的进程，其中浏览器渲染进程（浏览器内核）属于浏览器多进程中的一种，主要负责页面渲染，脚本执行，事件处理等")]),t._v(" "),a("li",[t._v("其包含的线程有：GUI 渲染线程（负责渲染页面，解析 HTML，CSS 构成 DOM 树）、JS 引擎线程、事件触发线程、定时器触发线程、http 请求线程等主要线程")])])]),t._v(" "),a("h2",{attrs:{id:"执行栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行栈"}},[t._v("#")]),t._v(" 执行栈")]),t._v(" "),a("p",[t._v("因为js是单线程语言，当遇到异步任务(如ajax操作等)时，不可能一直等待异步完成，再继续往下执行，在这期间浏览器是空闲状态，显而易见这会导致巨大的资源浪费。所以衍生了执行栈机制，在js运行时会将每一个js代码 执行的主任务压入栈中，当运行完毕会清空任务栈，在将异步的微任务压入栈中，执行后清空，之后再将宏任务压入栈中执行。")]),t._v(" "),a("h2",{attrs:{id:"关于执行中的线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于执行中的线程"}},[t._v("#")]),t._v(" 关于执行中的线程")]),t._v(" "),a("ul",[a("li",[t._v("主线程：也就是 js 引擎执行的线程，这个线程只有一个，页面渲染、函数处理都在这个主线程上执行。")]),t._v(" "),a("li",[t._v("工作线程：也称幕后线程，这个线程可能存在于浏览器或 js 引擎内，与主线程是分开的，处理文件读取、网络请求等异步事件。")])]),t._v(" "),a("h2",{attrs:{id:"js-异步执行的运行机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-异步执行的运行机制"}},[t._v("#")]),t._v(" js 异步执行的运行机制")]),t._v(" "),a("ul",[a("li",[t._v("所有任务都在主线程上执行，形成一个执行栈。")]),t._v(" "),a("li",[t._v('主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。')]),t._v(" "),a("li",[t._v('一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"。那些对应的异步任务，结束等待状态，进入执行栈并开始执行。')]),t._v(" "),a("li",[t._v("主线程不断重复上面的第三步。")])]),t._v(" "),a("h2",{attrs:{id:"宏任务与微任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#宏任务与微任务"}},[t._v("#")]),t._v(" 宏任务与微任务")]),t._v(" "),a("p",[t._v("异步任务分为 "),a("strong",[t._v("宏任务（macrotask）")]),t._v(" 与 "),a("strong",[t._v("微任务 (microtask)")]),t._v("，不同的API注册的任务会依次进入自身对应的队列中，然后等待 Event Loop 将它们依次压入执行栈中执行。")]),t._v(" "),a("ul",[a("li",[t._v("宏任务(macrotask)：\nscript(整体代码)、setTimeout、setInterval、UI 渲染、 I/O、postMessage、 MessageChannel、setImmediate(Node.js 环境)")]),t._v(" "),a("li",[t._v("微任务(microtask)：\nPromise、 MutaionObserver、process.nextTick(Node.js环境）")])]),t._v(" "),a("h2",{attrs:{id:"任务队列-event-queue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#任务队列-event-queue"}},[t._v("#")]),t._v(" 任务队列( Event Queue )")]),t._v(" "),a("p",[a("strong",[t._v("Event Loop(事件循环)中，每一次循环称为 tick, 每一次tick的任务如下：")])]),t._v(" "),a("ul",[a("li",[t._v("执行栈选择最先进入队列的宏任务(通常是script整体代码)，如果有则执行")]),t._v(" "),a("li",[t._v("检查是否存在 Microtask，如果存在则不停的执行，直至清空 microtask 队列")]),t._v(" "),a("li",[t._v("更新render(每一次事件循环，浏览器都可能会去更新渲染)")]),t._v(" "),a("li",[t._v("重复以上步骤")])]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("所有的任务可以分为同步任务和异步任务，同步任务，顾名思义，就是立即执行的任务，同步任务一般会直接进入到主线程中执行；而异步任务，就是异步执行的任务，比如 ajax 网络请求，setTimeout 定时函数等都属于异步任务，异步任务会通过任务队列的机制(先进先出的机制)来进行协调。具体的可以用下面的图来大致说明一下：\n"),a("img",{attrs:{src:"https://pic4.zhimg.com/80/v2-1337770fcc29d10325ee4eb127496fff_720w.jpg",alt:"'任务机制'"}})])])}),[],!1,null,null,null);s.default=v.exports}}]);